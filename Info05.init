En esta leccion nos vamos a meter más con el tema de las propiedades reactivas.
Como vimos anteriormente una propiedad reactiva es aquella que cuando sufre un cambio fuerza a la actualizacion del render.
Esto hay que usarse con cuidado con el fin de que el render no se ejecute cada dos por tres, solo cuando es necesario.
Por otro lado, estas properties tienen otra caracteristicas que las hacen muy útiles, la caracteristica a la que me estoy refiriendo es que permiten la transferencia de informacion desde el componente padre a si mismo.
Esto es muy facil de entender con un ejemplo.

Si habre de nuevo el componente HelloWord verás que properties ha sufrido una variacion:

En este ejemplo veremos los 4 tipos diferentes de properties que existe:

1.- Propiedades privadas, si una propiedad no quieres que sea modificable desde el exterior, simplemente añade state: true:
    translations: { type: Object, state: true },

2.- Si quieres puedes asignarle un attributo concreto a una propiedad. Dado que esta properti es de tipo Booleana, cuando hagas uso de ella tendrás que ponerlo de igual forma en el html pero precedida con el simbolo ?.
    hasSymbol: { type: Boolean, attribute: 'has-symbol' },
    <hello-word ?has-symbol="${hasSymbol}" ...>

3.- En el caso de strings vale con ponerla directamente:
    description: { type: String, attribute: 'description' },
    <hello-word description="Holita" ...>

4.- Por último si lo que quieres es enviar un objeto, tendrás que añadir un . antes del attributo o el nombre de la propertie.
    listString: { type: Object },
    <hello-word .listString="${[1,2,3...]}" ...>

Si te fijas bien, en el caso 3, el del string, le he añadido una opcion que es reflect: true, esta es una caracteristica extra que tienen las properties y que lo que permite es que una propiedad esté escuanchando.
Cuando tu cargas un componente en lit, este se carga y renderiza 1 vez con esos valores. Si tu quieres que el componente se quede escuchando a que ese propiedad pueda cambiar (desde fuera) debes añadirle esta propiedad.
Una manera de verlo más claramente es inspeccionar el componente desde el storybook, y manualmente cambiar la propiedad hasSymbol a false (por ejemplo) si te fijas no renderiza, pero si lo haces con la descripcion, si que se actualiza.
Cuando lo cambias desde el controls, el storybkook, fuerza el renderizado completo del componente.

El punto 4 es importante, pues todas las properties se pueden usar como objetos, de manera que si modificamos el storybook  para que todas sean objetos (estén precedidas por . y el attributo sea el nombre de la propertie) funcionará.
Pasaría de esto:
<hello-word
  ?has-symbol="${hasSymbol}"
  description="${description}"
  .listString="${listString}"
></hello-word>

a esto:
<hello-word
  .hasSymbol="${hasSymbol}"
  .description="${description}"
  .listString="${listString}"
></hello-word>

Como habrás visto, el storybook del componente HelloWord tambien ha sufrito un par de cambios.
Concretamente se ha añadido las propiedades que cambian y se les ha añadido un valor por defecto.
Esto se apreciará y podrás interactuar desde el apartado de controls en el storybook. Y te permitirá hacer pruebas del componente y ver si funciona correctamente con todas las casuisticas.

Los tipos de controles que permite el storybook son muy variados, y puedes buscar más informacion sobre ellos. Pero los mas usados son de tipo texto, numericos, objetos, selector o funciones.
Ya los iremos viendo poco a poco.



Por último, vamos a ver los eventos.
Con las properties vemos que hay una comunicacion entre padres a hijos de informacion. Con los eventos tenemos el método principal de transmision de información entre hijos a padres.

Los eventos pueden realizarse en cualquier momento (cuando renderiza el componente, cuando carga cierta informacion o cuando clica el cliente en alguna parte).

Creo que los mas sencillo será hacer un botón, y que lo veas cómodamente.
Lit captura eventos de javascript vanilla, de manera que crearemos un boton que capturará este evento:
  <button @click="${this.continue}">${this.translations['button']}</button>
Lo que le tenemos que pasar a @click es una funcion.
Puedes pasarsela de diferentes formas:
 . <button @click="${this.continue}" ...
 . <button @click="${() => this.continue()}" ...

Una vez que el cliente clicke, ejecutará el metodo continue que a su vez, lanzará un customEvent:

    this.dispatchEvent(
      new CustomEvent('continue', {
        detail: { example: 'texto', number: 1 },
        bubbles: true,
        composed: true,
      }),
    );

Vamos a explicarla:
  -this.dispatchEvent( -> Dispara un evento
  - new CustomEvent('continue', { -> Creamos un objeto con el constructor CustomEvent, esto nos creará un evento (que despues lanzaremos) con ciertas propiedades. El strin 'continue' será el nombre del evento.
  - detail: { example: 'texto', number: 1 }, -> dentro de detail podemos poner lo que queramos, un string, un objeto con campos variados, etc. Lo obligatorio es que tenga la key detail. Es la via principal de transmision de datos. Si no necesitas enviar datos no necesitas ponerlo pues es un campo obtativo.
Como sabes, cuando en javascript lanzamos un evento, por ejemplo click, este viaja por todo el DOM hasta llegar al padre de todos, la etiqueta html. En lit podemos controlar esta propagacion mediante las opciones 'bubbles' y 'composed' las cuales son obtativas y de forma predeterminada serán false. Vamos a verlos:
  - bubbles: true, -> El evento se propagará desde el elemento actual hasta la parte superior del arbol en el DOM (html).
  - composed: true, -> El evento puede atrabesar el shadowRoot, sin esto el evento solo se usará de forma interna en el componente. Esto se usa mucho cuando extiendes componentes de otro componente. (ya lo veremos).
 

En nuestros componentes, para que quede mas limpio guardaremos los eventos en una propiedad estatica events, pero recordemos que esto es algo que haremos nosotros, no es de lit. Esto lo hacemos unicamente por limpieza de código.
De manera que el evento quedará así:
  - this.dispatchEvent(
      new CustomEvent(HelloWord.events.continue, {
        detail: { example: 'text', number: 1 },
        bubbles: true,
        composed: true,
      }),
    );

Para capturar el evento, en el storybook, vamos a realizar lo siguiente.
    @continue="${handler}"

Gracias a la correcta configuracion de los decorators podemos ver el evento en la pestaña de actions del storybook.

Por último, pero no menos importante, debemos actualizar el readme con la nuevo informacion que hemos modificado en el componente. Fijate en la parte del evento.










Deberes:
Esta vez voy a ser algo más malo, y voy a pedirte varias cosas.

1.- modifica tu componente info-box para que reciva el texto que se muestra dentro del cuadrado verde como una propiedad. En caso de no recibir ningun texto, debes asegurarte que el alto no se ve afectado.

2.- crearás cun componente button-symbol, que recibirá un simbolo que puede ser uno de estos 8 ("←","*","+","-","/",".","=") o un numero del 0 al 9, y que al clicar emitirá un evento operation donde en el detail pondrás el simbolo enviado.
Deves verificar que el simbolo introducido es uno de los indicados, y en caso de que no, no renderizar nada.

3.- crearas el componente calculator-view, que incluirá los dos componentes anteriores.
Organizalos de la siguiente manera (usa el css o html que consideres):

Titulo de la pagina : "Calculador personalizada"

info-box
button-symbol (/) - button-symbol (*) - button-symbol (*) - button-symbol (←)
button-symbol (7) - button-symbol (8) - button-symbol (9) - button-symbol (+)
button-symbol (4) - button-symbol (5) - button-symbol (6) - button-symbol (-) 
button-symbol (1) - button-symbol (2) - button-symbol (3) - empty
empty             - button-symbol (0) - button-symbol (.) - button-symbol (=)  


Como podrás imaginar, lo que vamos ha hacer es una calculadora.
Cuando cliques en cada button-symbol, enviará el evento que modificará el texto del info-box y se irá escribiendo la operacion, te recomiendo ir añadiendo cada caracter a un array y gestionarlo desde este.
Por ahora solo debe hacer eso, escribir la operacion.
La parte de operar o borrar contenido, lo dejaremos para una segunda parte a no ser que te resulte muy facil.

Sobra decir que debes crear un stories y un readme bien documentado para cada componente.

Disfrutalo!!