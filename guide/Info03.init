Antes de empezar añadamos estas nuevas configuraciones:
Extensiones nuevas:
 - Error Lens -> Te muestra los errores de lintado
 - MDX -> Te ayudará a visualizar estos archivos

Por último he añadido nuevos paquetes y configuracion, debes hacer "npm i".

Comentarte que a partir de este momento tendrás que cumplir ciertas obligatoriedades a la hora de escribir.
Si has añadido las extensiones e instalado las nuevas dependencias las irás viendo y verás que esto aunque es en muchas ocasiones un coñazo, ayudarán a dejar el codigo mas limpio.
Estas normas las tendrás que acatar si o si, pues si no lo haces, no podrás completar el commit y te dará un error.



Ahora vamos a explicar algunas cosas importantes de los componentes. Aunque ya las vimos en la video llamada, así te quedan escritas aquí.
Te recomiendo que te pongas al lado el componente de HelloWord, porque voy a explicarlo paso a paso:

--------------------------
import { LitElement, html } from 'lit';
import { HelloWordStyle } from './HelloWord.style';
import es from '../assets/translations/es-ES.js';
--------------------------
Lo primero que veremos serán los imports, son los elementos que necesitamos cargar ANTES de crear el componente. En nuestro ejemplo tenemos 4 de 3 fuentes diferentes. Si te fijas podemos obtenerlos con y sin llaves. De que depende esto?
Sencillo, cuando quieres recuperar el componente/método/funcion/objecto por defecto que un archivo exporta (que no tiene por que tener uno) entonces le asignas un nombre y se guardará en el.
Si te fijas dentro del archivo de idiomas, se crea un objecto pero no se le asigna un nombre, directamente se exporta.

Por otro lado, en lit, recuperamos dos cosas dentro de llaves. Concretamente lo que estamos haciendo aquí es una desestructuracion. Cuando importas algo, ese algo siembre será un objeto, con los elementos que ese archivo ha exportado. Si el archivo tiene (por ejemplo) 20 exportaciones pero tu solo quieres 2, solo especificamos esas dos que queramos.
Esto aliviará la carga a la hora de crear el componente (generar el build).


----------------------------
const NAMESPACE = 'hello-word';
----------------------------
En esta linea creamos una constante que se utilizará en diferentes partes del componente.



--------------------------------------
export default class HelloWord extends LitElement {
--------------------------------------
En este punto estamos haciendo varias cosas. En orden seria.
- Estamos indicando que exportaremos el componente que estamos a punto de crear
- Indicamos que este componente será default de este archivo (en un archvio solo puede haber un unico default)
- Indicamos que será una clase de javascript
- Indicamos que el nombre de la clase será "HelloWord"
- Indicamos que esta clase extenderá de uno o mas de un componente*
- Indicamos que componentes se usarán de base para extender.

*Que quiere decir que un componente extiende. Que heredará todo lo que tenga el padre.
En el ejemplo típico, de las clases, hablamos de hacer grupos, por ejemplo:

Ser vivo > vertebrados > Mamiferos > Ser humano > Hombre > Oscar

Si indicamos que todos los vertebrados tienen que tener vertebras, podriamos añadir a vertebrados esa propiedad y todos los hijos que extiendan de vertebrados, lo heredarán.
Si no te queda claro avísame.

Con esto añadimos algunas funcionalidades de litElement a nuestro componente.



---------------------------------
static is = NAMESPACE;
---------------------------------
Cuando indicamos static, estamos asignando un valor fijo a este componente. En este caso le asignamos "is" puramente para que no sea cómodo. Podriamos haber puesto "pepita" y habria funcionado perfectamente, pero así nos es mas comodo diferenciarlo en el futuro.



---------------------------------
  static styles = HelloWordStyle;
---------------------------------
Indiamos que estilos de css vamos a usar. Heredado de Lit


---------------------------------
  constructor() {
    super();

    this.translations = null;
  }
---------------------------------
Constructos e inicializador de propiedades.
Algo importante a entender que estamos creando un objecto. Este objeto es muy similar a un objeto JSON, el cual tiene propiedades/keys dentro.
En este caso, en el constructor creamos la propiedad "translations" con el fin de inicializarla. Tambien añadimos "super()" debido a que como extendemos de otro objeto, tenemos que ejecutar primero el constructor heredado antes que el nuestro.
Es importante entender la diferencia entre propiedades internas y properties externas o rectivas. Ahora las comentamos.



-----------------------------------------
  static properties = {
    translations: { type: Object },
  };
-----------------------------------------
En litElements, las propiedades internas se pueden convertir en properties externas, en el momento que se añaden a esta lista, serán escuchadas. Que quiere decir esto? que en el momento que se actualicen/cambien, se volverá a realizar un render del componente para actualizarse a los nuevos valores.
Algo importante de las properties es que pueden escuchar fuera del componente, y es la via principal de obtencion de datos. Esto lo veremos en la proxima lección.
Para diferenciaslas mas facilmente entre propiedades internas u properties externas prefiero nombrarlas, propiedades y properties.


---------------------------------------------
  async connectedCallback() {
    super.connectedCallback();

    await this.loadTranslations();
  }
---------------------------------------------
Primero de todo, tienes que entender que las funciones dentro de una clase se denominan métodos.
Y estos metodos pueden ser sincronos (lineales) o asincronos (con llamadas internas).
Para diferenciarlos, se usa la nomenglatura "async" antes del método para poder decirle al componente como se tiene que comportar.
Por otro lado, si te fijas parece que he creado un metodo con nombre "connectedCallback" pero nunca se ejecuta....entonces como puede ser que si que se ejecute?
La respuesta está en los ciclos de vida de lit. Lit tiene una serie de métodos que ejecuta en un orden establecido y tras ciertas circunstancias concretas las puede volver a ejectuar. En concreto el "connectedCallback" es un metodo que se ejecuta, antes de la ejecucion del render, una sola vez y es donde se recumienda añadir las llamadas necesarias para la ejecucion correcta del componente.
Puedes consultar los ciclos de vida de lit aquí:
https://lit.dev/docs/components/lifecycle/



------------------------------------------
  async loadTranslations(locale = navigator.language) {
    try {
      const translateFunction = HelloWord.localizeNamespaces.find(elem =>
        Object.keys(elem).some(key => key === HelloWord.is),
      )[HelloWord.is];
      this.translations = await translateFunction(locale);
      console.log(this.translations);
    } catch (error) {}
  }
------------------------------------------
Este método me lo tuve que sacar un poco de la manga pues a nosotros nos llega de librerias internar. Lo que hace es cargar las traducciones correctas de este componete.
No hace falta que lo revises mucho, pues como digo, me lo saqué de la manda para poder avanzar. Mas adelante haremos que sea automático ;)


-------------------------------------------
  static localizeNamespaces = [
    {
      [NAMESPACE]: locale => {
        const namespaces = {
          'es-ES': () => Promise.resolve(es),
          'en-GB': () => import('../assets/translations/en-GB.js'),
        };
        return namespaces[locale]();
      },
    },
  ];
-------------------------------------------
Para especificar las traducciones de nuestro componente usaremos esta nomengratura. Como puedes ver no es nada del otro mundo. Si tienes dudas con lo que hace, avísame.



----------------------------------------------
  render() {
    return this.translations ? html`<h1>${this.translations['title']}</h1>` : html``;
  }
----------------------------------------------
Y ya por último, el render, es la funcion que da visibilidad al componente y que hará que veas algo. Se ejecutará cuando la vida de lit lo indique y en este ejemplo, se ejecuta dos veces.
1º al arrancar despues de haber ejecutado el connectedCallback
2º dado que el metodo connectedCallback es asincrono cuando la funcion interna finaliza y la property "translations" se actializa se vuelve a renderizar.
Internamente tenemos un ternario para que en caso de no tener las traducciones, no intente acceder a ellas.


Con esto queda explicado un componente lit básico.