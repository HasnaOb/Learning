Aquí podrás encontrar algunos códigos utiles y su explicación. Sientete libre de añadir o modificar.


GIT:

####################
#  git clone ruta  #
####################
En la ubicación donde se encuentre la consola, creará el repositorio


############################
#  git checkout feat/name  #
############################
Te cambias de la rama en la que estás a una ya creada


###############################
#  git checkout -b feat/name  #
###############################
Crea la rama indicada y te mueves a ella


#######################
#  git branch         #
#  git branch --list  #
#######################
Muestra las ramas existentes en tu local


##########################
#  git branch --list -r  #
##########################
Muestra las ramas existentes en local y servidor


#############################
#  git branch -d feat/name  #
#  git branch -D feat/name  #
#############################
Borra una rama. En caso de que la rama no se llegase a subir al servidor, dará error. Para evitarlo usar -D


#########################
#  git add "file/name"  #
#  git add .            #
#########################
Añade al staged un archivo en especifico (modo ruta) p añade TODOS los archivos modificados (modo punto ".").


###############################
#  git commit -m "feat:name"  #
###############################
Creas un commit con lo que tengas en el staged


########################
#  git commit --amend  #
########################
Te permite modificar el commit anterior, añadiendo archivos que tengas en staged y te permite modificar el texto del commit


##################################
#  git commit --amend --no-edit  #
##################################
Igual al anterior pero no te dejará modificar el texto, unicamente añadriá los archivos al commit anterior


##############
#  git pull  #
##############
Descargar todos los archivos modificar en la rama en la que estés


###################################
#  git pull --rebase origin main  #
###################################
Añade los commits de la rama principal, por debajo de tus commits.
Para entender esto mas facilmente, imaginate que A y B están trabajando en un mismo repo con sus propias ramas.
A termina y mergea a main.
B podria tener conflictos porque tiene su rama en una version anterior al mergeo de A. Así que antes de mergear a master, ejecuta este comando y se trae los cambios de A, colocandolos antes de sus propios commits- Esto obviamente puede provocar conflictos, pero los puedes resolver en el local facilmente.


###############
#  git fetch  #
###############
Actualiza el repositorio y todas las ramas


##############
#  git push  #
##############
Sube tus commits y/o tu rama al repositorio git


##############################################
#  git stash -u save "nombre personalizado"  #
##############################################
Guarda todos los cambios realizados en la lista de stash bajo el nombre indicado.


####################
#  git stash list  #
####################
Muestra la lista de stash guardados


###############################
#  git stash apply            #
#  git stash apply stash@{0}  #
###############################
Recupera los archivos modificados dentro de un stash.
Si no se le especifica el orden (stash@{0}) se recupera los ultimos guardados


#############################
#  git reset --soft head^1  #
#############################
Te posicionas en el commit anterior (como si aun no lo hubieras realizado) recuperando los archivos modificados


############################
#  git reset -hard head^1  #
############################
Te posiciona en el commit anterior (como si aun no lo hubieras realizado) perdiendo todos los cambios.
CUIDADO: Si no los tenias almacenados en el servidor, se pierden y no se pueden recuperar.



